#include "./perft.h"

// Returns the current time in milliseconds
long getTimeMs() {
  using namespace std::chrono;
  return duration_cast<milliseconds>(system_clock::now().time_since_epoch()).count();
}

// ======================
//     Perft Testing
// ======================

// Init nodes_real, used for counting
U64 nodes_real;

/**
 * A recursive function that performs a performance test (Perft) for a given depth.This function is
 * used to verifythe move generation logic by comparing the number of nodes generated at a given
 * depth with known test positions (StockFish).
 *
 * @param depth; The depth to which the performance test will evaluate.
 * @param game; An instance of ChessGame representing the current state of the game.
 */
void perft(int depth, ChessGame game) {
  if (depth == 0) {
    nodes_real++;
    return;
  }
  game.moves.generate_moves(game.board);
  for (int i = 0; i < game.moves.moves_count; i++) {
    game.board.copyBoard();
    if (!game.MakeMove(game.moves.moves[i])) continue;

    perft(depth - 1, game);
    game.board.revertBoard();
  }
}

/**
 * Initiates a performance test (Perft) starting from the current game position and evaluates to
 * a specified depth. This function logs the move breakdown at the initial depth, showing the number
 * of leaf nodes each move generates. It supports both console and file output for reviewing the
 * results.
 *
 * @param depth; The depth to which the performance test will evaluate.
 * @param game; A reference to an instance of ChessGame, representing the current game state.
 */
void perftTest(int depth, ChessGame& game) {
  std::ofstream outFile;  // Declare the ofstream object for file output

  // Check if file output is enabled and open the results file
  if (game.file_output) {
    outFile.open(".\\test\\results_lb.txt", std::ios::app);  // Open and clear contents
    if (!outFile) {
      std::cerr << "Failed to open output file results_lb.txt" << std::endl;
      return;
    }
  }
  // Log the depth being tested
  if (game.file_output) {
    outFile << "\ngo depth " << depth << std::endl;
  } else {
    std::cout << "\n     Perft performance test\n\n" << std::endl;
  }

  // Log the depth being tested
  game.moves.generate_moves(game.board);
  long cummulative_nodes = 0;
  long old_nodes = 0;
  U64 nodes = 0;

  // Record start time for the test
  long start = getTimeMs();

  // Loop over all generated moves at the current level
  for (int i = 0; i < game.moves.moves_count; i++) {
    // Preserve board state
    game.board.copyBoard();

    if (!game.MakeMove(game.moves.moves[i])) {
      // Skip illegal moves
      // Undo is already done inside MakeMove()
      continue;
    }

    // Track nodes before making the move
    cummulative_nodes = nodes_real;

    // Call perft driver recursively
    perft(depth - 1, game);

    // Calculate nodes generated by this move
    old_nodes = nodes_real - cummulative_nodes;

    // Revert to previous state (Undo move)
    game.board.revertBoard();

    // Output move and node count to either file or console
    if (game.file_output) {
      outFile << square_to_position[game.moves.get_move_source(game.moves.moves[i])]
              << square_to_position[game.moves.get_move_target(game.moves.moves[i])];
      if (game.moves.get_move_promoted(game.moves.moves[i])) {
        outFile << ASCII_PIECES_LOWER[game.moves.get_move_promoted(game.moves.moves[i])];
      }
      outFile << ": " << old_nodes << '\n';

    } else {
      std::cout << square_to_position[game.moves.get_move_source(game.moves.moves[i])]
                << square_to_position[game.moves.get_move_target(game.moves.moves[i])];

      if (game.moves.get_move_promoted(game.moves.moves[i])) {
        std::cout << ASCII_PIECES_LOWER[game.moves.get_move_promoted(game.moves.moves[i])];
      }
      std::cout << ": " << old_nodes << '\n';
    }
  }

  // Print final results
  if (game.file_output) {
    outFile << "Nodes searched: " << nodes_real << "\n";

  } else {
    std::cout << "\n       Depth: " << depth << '\n'
              << "Nodes searched: " << nodes_real << '\n'
              << "          Time: " << (getTimeMs() - start) << " ms\n\n";
  }

  // Reset the node counter for the next test
  nodes_real = 0ULL;
}
